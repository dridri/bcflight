#pragma once


#define	IEEE80211_RADIOTAP_F_CFP		0x01	// sent/received during CFP
#define	IEEE80211_RADIOTAP_F_SHORTPRE	0x02	// sent/received with short preamble
#define	IEEE80211_RADIOTAP_F_WEP		0x04	// sent/received with WEP encryption
#define	IEEE80211_RADIOTAP_F_FRAG		0x08	// sent/received with fragmentation
#define	IEEE80211_RADIOTAP_F_FCS		0x10	// frame includes FCS
#define	IEEE80211_RADIOTAP_F_DATAPAD	0x20	// frame has padding between 802.11 header and payload (to 32-bit boundary)
#define IEEE80211_RADIOTAP_F_BADFCS		0x40	// bad FCS
#define IEEE80211_RADIOTAP_F_RX_BADPLCP	0x0002	// frame has bad PLCP
#define IEEE80211_RADIOTAP_F_TX_FAIL	0x0001	// failed due to excessive retries
#define IEEE80211_RADIOTAP_F_TX_CTS		0x0002	// used cts 'protection'
#define IEEE80211_RADIOTAP_F_TX_RTS		0x0004	// used rts/cts handshake
#define IEEE80211_RADIOTAP_F_TX_NOACK	0x0008	// don't expect an ack

enum ieee80211_radiotap_mcs_have {
	IEEE80211_RADIOTAP_MCS_HAVE_BW = 0x01,
	IEEE80211_RADIOTAP_MCS_HAVE_MCS = 0x02,
	IEEE80211_RADIOTAP_MCS_HAVE_GI = 0x04,
	IEEE80211_RADIOTAP_MCS_HAVE_FMT = 0x08,
	IEEE80211_RADIOTAP_MCS_HAVE_FEC = 0x10,
	IEEE80211_RADIOTAP_MCS_HAVE_STBC = 0x20,
};

enum ieee80211_radiotap_mcs_flags {
	IEEE80211_RADIOTAP_MCS_BW_MASK = 0x03,
	IEEE80211_RADIOTAP_MCS_BW_20 = 0,
	IEEE80211_RADIOTAP_MCS_BW_40 = 1,
	IEEE80211_RADIOTAP_MCS_BW_20L = 2,
	IEEE80211_RADIOTAP_MCS_BW_20U = 3,

	IEEE80211_RADIOTAP_MCS_SGI = 0x04,
	IEEE80211_RADIOTAP_MCS_FMT_GF = 0x08,
	IEEE80211_RADIOTAP_MCS_FEC_LDPC = 0x10,
	IEEE80211_RADIOTAP_MCS_STBC_MASK = 0x60,
	IEEE80211_RADIOTAP_MCS_STBC_1 = 1,
	IEEE80211_RADIOTAP_MCS_STBC_2 = 2,
	IEEE80211_RADIOTAP_MCS_STBC_3 = 3,
	IEEE80211_RADIOTAP_MCS_STBC_SHIFT = 5,
};
